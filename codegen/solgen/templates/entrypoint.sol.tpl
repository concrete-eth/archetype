// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

/* Autogenerated file. Do not edit manually. */

{{ range .Imports }}
import "{{ . }}";
{{- end }}

abstract contract {{.Name}} is {{ range $i, $v := .Interfaces }}{{ if $i }}, {{ end }}{{ $v }}{{ end }} {
    function {{.ArchParams.MultiActionMethodName}}(
        uint8[] memory actionIds,
        uint8[] memory actionCount,
        bytes[] memory actionData
    ) external {
        uint256 actionIdx = 0;
        for (uint256 i = 0; i < actionIds.length; i++) {
            uint256 numActions = uint256(actionCount[i]);
            for (uint256 j = actionIdx; j < actionIdx + numActions; j++) {
                _executeAction(actionIds[i], actionData[j]);
            }
            actionIdx += numActions;
        }
    }

    function _executeAction(uint8 actionId, bytes memory actionData) private {
        {{- range $index, $schema := .Schemas }}
        if (actionId == {{$index}}) {
            {{SolidityActionStructNameFn $schema.Name}} memory action = abi.decode(
                actionData,
                ({{SolidityActionStructNameFn $schema.Name}})
            );
            {{SolidityActionMethodNameFn $schema.Name}}(action);
        } else {{- end }} {
            revert("Entrypoint: Invalid action ID");
        }
    }

    {{- range $schema := .Schemas }}
    {{ if $schema.Values }}
    function {{SolidityActionMethodNameFn .Name}}({{SolidityActionStructNameFn $schema.Name}} memory action) public virtual;
    {{- else }}
    function {{SolidityActionMethodNameFn .Name}}() public;
    {{- end }}
    {{- end }}
}
