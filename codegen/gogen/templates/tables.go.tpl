/* Autogenerated file. Do not edit manually. */

package {{.Package}}

import (
    "reflect"

    "github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/concrete/lib"
    "github.com/ethereum/go-ethereum/common"

    archtypes "github.com/concrete-eth/archetype/types"
	
    {{ range .Imports }}
	"{{.}}"
	{{ end }}
)

var (
	_ = common.Big1
)

{{ if .Comment }}
/*
{{ .Comment }}
*/
{{ end }}

{{ if .Schemas }}
const (
    {{- range $index, $element := .Schemas }}
    TableId_{{.Name}}{{ if eq $index 0 }} uint8 = iota{{ end }}
    {{- end }}
)
{{ end }}

var Tables = map[uint8]archtypes.TableMetadata{
    {{- range .Schemas }}
    TableId_{{.Name}}: {
        Id: TableId_{{.Name}},
        Name: "{{.Name}}",
        MethodName: "get{{.Name}}Row",
        Keys: []string{
            {{- range .Keys }}
            "{{.Name}}",
            {{- end }}
        },
        Columns: []string{
            {{- range .Values }}
            "{{.Name}}",
            {{- end }}
        },
        Type: reflect.TypeOf(RowData_{{.Name}}{}),
    },
    {{- end }}
}

/*
var TableIdsByMethodName = map[string]uint8{
    {{- range .Schemas }}
    "get{{.Name}}Row": TableId_{{.Name}},
    {{- end }}
}
 */

{{ if .Experimental }}
type TableUpdateHandler func(tableId uint8, rowKey []interface{}, columnIndex int, value []byte)
{{ end }}

type State struct {
	datastore  lib.Datastore
    {{- range .Schemas }}
    {{_lowerFirstChar .Name}} *datamod.{{.Name}}{{if $.Experimental}}WithHooks{{ end }}
    {{- end }}
    {{- if .Experimental }}
	OnSetTable TableUpdateHandler
    {{- end }}
}

func NewState(datastore lib.Datastore) *State {
	return &State{
		datastore: datastore,
	}
}

{{ if .Experimental }}
func (s *State) SetTableUpdateHandler(handler TableUpdateHandler) {
	s.OnSetTable = handler
}
{{ end }}

{{ range .Schemas }}
{{ if $.Experimental }}
func (s *State) {{.Name}}() *datamod.{{.Name}}WithHooks {
    {{- $fieldName := _lowerFirstChar .Name}}
    if s.{{$fieldName}} == nil || (s.{{$fieldName}}.OnSetRow == nil && s.OnSetTable != nil) {
        s.{{$fieldName}} = datamod.New{{.Name}}WithHooks(datamod.New{{.Name}}(s.datastore))
        s.{{$fieldName}}.OnSetRow = func(rowKey []interface{}, columnIndex int, value []byte) {
            if s.OnSetTable != nil {
                s.OnSetTable(TableId_{{.Name}}, rowKey, columnIndex, value)
            }
        }
    }
    return s.{{$fieldName}}
}
{{ else }}
func (s *State) {{.Name}}() *datamod.{{.Name}} {
    {{- $fieldName := _lowerFirstChar .Name}}
    if s.{{$fieldName}} == nil {
        s.{{$fieldName}} = datamod.New{{.Name}}(s.datastore)
    }
    return s.{{$fieldName}}
}
{{ end }}
{{ end }}

{{ range .Schemas }}
func (s *State) Get{{.Name}}Row(
    {{- range .Keys }}
    {{.Name}} {{.Type.GoType}},
    {{- end }}
) *datamod.{{.Name}}Row {
    return s.{{.Name}}().Get(
        {{- range .Keys }}
        {{.Name}},
        {{- end }}
    )
}
{{ end }}

{{ range $schema := .Schemas }}
type RowData_{{.Name}} struct{
    {{- range .Values }}
    {{.PascalCase}} {{.Type.GoType}} `json:"{{.Name}}"`
    {{- end }}
}
{{ range .Values }}
func (row *RowData_{{$schema.Name}}) Get{{.PascalCase}}() {{.Type.GoType}} {
    return row.{{.PascalCase}}
}
{{ end }}
{{ end }}

func GetData(datastore lib.Datastore, method *abi.Method, args []interface{}) (interface{}, bool) {
	switch method.Name {
	{{- range .Schemas }}
	case "get{{.Name}}Row":
		row := datamod.New{{.Name}}(datastore).Get(
			{{- range .Keys }}
			args[{{.Index}}].({{.Type.GoType}}),
			{{- end }}
		)
		return RowData_{{.Name}}{
			{{- range .Values }}
			{{.PascalCase}}: row.Get{{.PascalCase}}(),
			{{- end }}
		}, true
	{{- end }}
	}
	return nil, false
}
